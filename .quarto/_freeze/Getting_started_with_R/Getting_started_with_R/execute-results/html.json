{
  "hash": "d75a4b80ed3754526318e8e3548ea999",
  "result": {
    "markdown": "---\ntitle: \"Loading and visualizing data in R\"\nauthor: \"Manny Gimond\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n------------------------------------------------------------------------\n\n[Data for this tutorial can be downloaded [from here](./data.zip). Don't forget to unzip the files to a dedicated folder on your computer.]{.block1}\n\n------------------------------------------------------------------------\n\nR is a data analysis environment. RStudio is a desktop interface to R (sometimes referred to as an integrated development environment-or IDE for short). Unlike most desktop environments you have been exposed to so far, R does not take instructions from a point-and-click environment, its instructions are provided by simple lines of text.\n\n------------------------------------------------------------------------\n\n# Launching the RStudio software\n\nRStudio software comes in two flavors: a server based application and a desktop based application. Some of you may have already used the server based version of RStudio that you access via a web browser. In this course, we will make use of the desktop version of the software (i.e. an installed version of RStudio and R). Note that you can install R and RStudio on your personal computer if you want to tackle these exercises independent of the computer lab. For instructions on installing R and RStudio, see [here](https://posit.co/download/rstudio-desktop/).\n\nClick on the windows icon and launch RStudio.\n\n![](img/rstudio.png){width=\"244\"}\n\n------------------------------------------------------------------------\n\n# Setting up the R environment\n\n## Installing packages\n\nThis course will make use of four packages: `sf` which is used to load, manipulate and visualize vector files; `terra` which is used to load, manipulate and visualize raster files; `spatstat` which will be used for point pattern analysis; `spdep` which will be used to analyze spatial autocorrelation in the data.\n\nYou can install packages in one of two ways: via command line or via the RStudio interface.\n\n### Option 1: Command line\n\nIf you choose to install the packages via the command line, type the following lines of code in the console, one line at a time.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-1_ad84b48f33d3b2bce1930da72f2e6a2d'}\n\n```{.r .cell-code}\ninstall.packages(\"sf\")\ninstall.packages(\"spatstat\")\ninstall.packages(\"terra\")\ninstall.packages(\"spdep\")\n```\n:::\n\n\n### Option 2: RStudio interface\n\nIf you choose to install the packages via RStudio's pull-down menu, click on the **Packages \\>\\> Install** tab and list the packages to be installed in the *Packages* field separated by commas.\n\n![](img/image1.jpg)\n\n> If you are given the option to either have R compile some of the libraries or to accept the binaries, opt for the compilation option.\n\n## Opening a new R script\n\nIf an empty R script file is not open in RStudio open a new one now.\n\n![](img/image2.jpg){width=\"242\"}\n\nR scripts are usually saved using the .R extension. For this tutorial, you may choose to name the script *r_intro.R*. Make sure to save this script on a regular basis as you add/modify pieces of code.\n\n## Setting an R session's work space\n\nIf you plan to read or write files from/to a directory, you might find it beneficial to explicitly define the R session's project folder. To set a session's working directory, go to **Session \\>\\> Set Working Directory \\>\\> Choose Directory**. In this example, you will want to set the working directory to the folder that houses the sample dataset.\n\n![](img/image3.jpg){width=\"409\"}\n\n## Loading (activating) packages\n\nInstalling packages under your user profile is a one-time process, but to access the package contents in a current R session you must explicitly load its contents via the `library` function.\n\nIn this exercise, we will load and prep the data for a point pattern analysis using the `spatstat` package. We will therefore not need to load the `spdep` package which won't be used until we tackle spatial autocorrelation in later exercises.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-2_f456ba6f850110dc50f79c3fc0ab969d'}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(spatstat)\nlibrary(terra)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n# Loading GIS data into R\n\n## Loading shapefiles\n\nNote that R will recognize vector data models stored as shapefiles, but it will *not* recognize GIS files stored in geodatabases.\n\nFirst, we will load the Massachusetts polygon shapefile into R and save the contents of that shapefile to an object called `s2`. Note the use of the assignment operator `<-` which *assigns* the output to its right to the object to its left. The name of the shapefile must end with the `*.shp` extension, but note that the function understands that the shapefile consists of *multiple* files.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-3_f62bc0c11f685753eb4f293595e6f692'}\n\n```{.r .cell-code}\ns2 <- st_read(\"MA.shp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MA' from data source \n  `C:\\Users\\mgimond\\Documents\\Github\\es214_support_tutorials\\Getting_started_with_R\\MA.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1 feature and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 623157.2 ymin: 4577879 xmax: 922141 ymax: 4756659\nProjected CRS: NAD83 / UTM zone 18N\n```\n:::\n:::\n\n\n> NOTE: if you get the error message `Error: Cannot open \"MA.shp\"; The file doesn't seem to exist.`, then you probably did not properly set the working directory (see earlier step) or you have a syntax error in the file name.\n\nR can store spatial objects in different internal formats. `spatstat`'s functions require that a specific spatial format be used. The `MA` states layer will be used to define the study extent. This will require that it be converted to an `owin` formatted object for use with `spatstat`. We will make use of the `as.owin` function to convert the `s2` object to an `owin` object.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-4_94889591883bd44b6af5c5c17833a60a'}\n\n```{.r .cell-code}\nw  <- as.owin(s2)\n```\n:::\n\n\nThe coordinate unit associated with the spatial object inherits the underlying coordinate system's map units--`meters` in this example. Such small units may make it difficult to interpret the output of some operations given that some analyses may generate very small values (i.e. density based analyses) or very large values (i.e. distance based analyses). We will therefore convert the map units from meters to kilometers using the `rescale.owin()` function. Note that 1000 m = 1 km.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-5_d65beb887198ad864aabeca03e6d8f2e'}\n\n```{.r .cell-code}\nw.km <- rescale.owin(w, 1000)\n```\n:::\n\n\nThe second parameter in the `rescale.owin()` function, `1000`, tells R to divide the planar unit by 1000.\n\nNext we will load the Walmart stores shapefile (`Walmarts.shp`) using the same functions, but instead of storing the shapefile as a polygon boundary, we will convert the point shapefile to a `ppp` formatted point object.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-6_a2f59b6cfde7fc90d2f0c30226b30650'}\n\n```{.r .cell-code}\ns1 <- st_read(\"Walmarts.shp\")  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Walmarts' from data source \n  `C:\\Users\\mgimond\\Documents\\Github\\es214_support_tutorials\\Getting_started_with_R\\Walmarts.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 44 features and 40 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 640627.2 ymin: 4614803 xmax: 869353.2 ymax: 4738331\nProjected CRS: NAD83 / UTM zone 18N\n```\n:::\n\n```{.r .cell-code}\np  <- as.ppp(s1)  # creates a ppp object\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in as.ppp.sf(s1): only first attribute column is used for marks\n```\n:::\n\n```{.r .cell-code}\np.km <- rescale.ppp(p, 1000)\n```\n:::\n\n\nBy default, R will adopt a rectangular extent for the point data.\n\n![](img/image5.jpg){width=\"220\"}\n\nGiven that we will be defining the extent to match that of the Massachusetts boundaries, we will need to explicitly define the study extent for the point object.\n\n![](img/image6.jpg){width=\"220\"}\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-7_99340e2fd6df6347b76f92024439ad82'}\n\n```{.r .cell-code}\nWindow(p.km) <- w.km\n```\n:::\n\n\nThere is one more thing that we will need to do that will make the data behave with `spatstats` tools: remove the layer's attribute information (attributes are also known as *marks* in the point pattern analysis world). The point attributes will not be needed here since our interest is in the pattern generated by the points and not by their attribute values.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-8_2c5edcb7ec208278707c424e213af30c'}\n\n```{.r .cell-code}\nmarks(p.km) <- NULL\n```\n:::\n\n\n## Loading Raster Files\n\nNext, we will load the population density raster file `pop_sqmile.img` using the `rast()` function from the `terra` package, then we'll convert it to an `im` object recognized by spatstat and name the object `r.km` once re-scaled.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-9_c82ea722def9e3aebfc800082ce8a1a6'}\n\n```{.r .cell-code}\nimg  <- rast(\"pop_sqmile.img\") # Load raster file\ndf <- as.data.frame(img, xy = TRUE) # Convert to XYZ data table\nr    <- as.im(df)             # Convert XYZ table to im object\nr.km <- rescale.im(r, 1000)\n```\n:::\n\n\n------------------------------------------------------------------------\n\n# Visualizing Spatial Objects\n\nWe can plot the raster and overlay it with the point layer. Several plotting options are available including the base `plot` function which will be used in this tutorial. However, there are many R packages that will help improve the \"look\" of a map including `tmap` and `ggplot2`.\n\nIn the following code chunk, we will plot the point data. We'll assign a yellow fill color to the point symbol. The point symbol type is defined by the `pch = 21` parameter.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-10_d2bd437a43fc707319ea287065f8b06f'}\n\n```{.r .cell-code}\nplot(p.km, pch = 21, bg = \"yellow\", main = \"Walmart stores\")\n```\n\n::: {.cell-output-display}\n![](Getting_started_with_R_files/figure-html/unnamed-chunk-10-1.png){width=384}\n:::\n:::\n\n\nPoint symbol types are defined by a number. The above point symbol is number `21`. Other point symbols available in R are shown below:\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-11_dabb40629bb62ee874c856ee212007c5'}\n::: {.cell-output-display}\n![](Getting_started_with_R_files/figure-html/unnamed-chunk-11-1.png){width=384}\n:::\n:::\n\n\nTo plot a raster, you can use the `image` function (as well as the `plot` function). Here, we'll adopt a built-in color scheme using the `hcl.colors` function.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-12_5b84482766db0b6f19a22f64fc84fe7e'}\n\n```{.r .cell-code}\nimage(r.km, main = \"Population density\", col = hcl.colors(50, rev = TRUE))\n```\n\n::: {.cell-output-display}\n![](Getting_started_with_R_files/figure-html/unnamed-chunk-12-1.png){width=384}\n:::\n:::\n\n\nIn the following chunk of code, we will plot both the raster and point layers. To add a \"layer\" to an existing map, include the `add = TRUE` parameter.\n\n\n::: {.cell hash='Getting_started_with_R_cache/html/unnamed-chunk-13_1a08cef9170c29585662148871502367'}\n\n```{.r .cell-code}\nimage(r.km, main = \"Population density\", col = hcl.colors(50, rev = TRUE))\nplot(p.km, pch = 16, add = TRUE)\n```\n\n::: {.cell-output-display}\n![](Getting_started_with_R_files/figure-html/unnamed-chunk-13-1.png){width=384}\n:::\n:::\n\n\nThis wraps up this tutorial.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}